<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Interactive Rubik's Cube with Lock & Slice Rotation</title>
<style>
  body, html {
    margin: 0; padding: 0;
    height: 100%;
    background: #121212;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  #container {
    width: 100vw;
    height: 80vh;
    max-width: 600px;
    max-height: 600px;
    touch-action: none;
  }

  #controls {
    width: 100vw;
    max-width: 600px;
    padding: 12px;
    text-align: center;
    user-select: none;
  }

  button {
    background: #1f1f1f;
    border: none;
    padding: 10px 20px;
    margin: 6px;
    border-radius: 6px;
    font-size: 16px;
    color: #eee;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  button:hover {
    background: #333;
  }

  @media (max-width: 480px) {
    #container {
      height: 60vh;
      max-width: 100vw;
    }
    button {
      padding: 8px 14px;
      font-size: 14px;
      margin: 4px;
    }
  }
</style>
</head>
<body>
  <div id="container"></div>
  <div id="controls">
    <button id="lockBtn">Lock Cube (Enable Slice Rotation)</button>
    <button id="scrambleBtn">Scramble</button>
    <button id="solveBtn">Solve</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.min.js"></script>

  <script>
  (() => {
    const container = document.getElementById('container');

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(5, 5, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0x121212);
    container.appendChild(renderer.domElement);

    // OrbitControls for full cube rotation (initially enabled)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.enablePan = false;
    controls.minDistance = 5;
    controls.maxDistance = 15;

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(0, 5, 5);
    scene.add(directionalLight);

    // Cube parameters
    const cubeSize = 3;
    const cubeGap = 0.05;
    const cubeUnitSize = 1;
    const cubies = [];

    // Face colors
    const FACE_COLORS = {
      U: 0xffff00, // Up - Yellow
      D: 0xffffff, // Down - White
      F: 0xff0000, // Front - Red
      B: 0xff8000, // Back - Orange
      L: 0x0000ff, // Left - Blue
      R: 0x00ff00  // Right - Green
    };

    // Create materials for each cubie face
    function createCubieMaterials(x, y, z) {
      const black = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const materials = [];

      materials[0] = (x === 1) ? new THREE.MeshBasicMaterial({ color: FACE_COLORS.R }) : black; // Right
      materials[1] = (x === -1) ? new THREE.MeshBasicMaterial({ color: FACE_COLORS.L }) : black; // Left
      materials[2] = (y === 1) ? new THREE.MeshBasicMaterial({ color: FACE_COLORS.U }) : black; // Top
      materials[3] = (y === -1) ? new THREE.MeshBasicMaterial({ color: FACE_COLORS.D }) : black; // Bottom
      materials[4] = (z === 1) ? new THREE.MeshBasicMaterial({ color: FACE_COLORS.F }) : black; // Front
      materials[5] = (z === -1) ? new THREE.MeshBasicMaterial({ color: FACE_COLORS.B }) : black; // Back

      return materials;
    }

    // Create cubies
    for(let x = -1; x <=1; x++) {
      for(let y = -1; y <=1; y++) {
        for(let z = -1; z <=1; z++) {
          const geometry = new THREE.BoxGeometry(cubeUnitSize, cubeUnitSize, cubeUnitSize);
          const materials = createCubieMaterials(x, y, z);
          const cubie = new THREE.Mesh(geometry, materials);

          cubie.position.set(
            x * (cubeUnitSize + cubeGap),
            y * (cubeUnitSize + cubeGap),
            z * (cubeUnitSize + cubeGap)
          );

          cubie.userData = { x, y, z };
          scene.add(cubie);
          cubies.push(cubie);
        }
      }
    }

    // Group for rotating slices
    const rotatingGroup = new THREE.Group();
    scene.add(rotatingGroup);

    // Rotation state variables
    let isRotating = false;
    let rotationAxis = null;
    let rotatingCubies = [];
    let rotationStart = 0;
    let rotationAngle = 0;
    let rotationSpeed = Math.PI / 20;

    // Move queue for animation
    const moveQueue = [];

    // Function to get cubies on layer
    function getCubiesOnLayer(axis, index) {
      return cubies.filter(c => Math.round(c.userData[axis]) === index);
    }

    // Rotate a layer
    function rotateLayer(axis, index, clockwise = true) {
      if (isRotating) return;
      isRotating = true;
      rotationAxis = axis;
      rotatingCubies = getCubiesOnLayer(axis, index);

      rotatingCubies.forEach(c => {
        scene.remove(c);
        rotatingGroup.add(c);
      });

      rotatingGroup.rotation.set(0, 0, 0);
      rotationStart = 0;
      rotationAngle = clockwise ? -Math.PI/2 : Math.PI/2;
    }

    // Animate rotation
    function animateRotation() {
      if (!isRotating) return;
      const delta = rotationSpeed;
      rotationStart += delta;

      if (rotationStart >= Math.abs(rotationAngle)) {
        rotatingGroup.rotation[rotationAxis] = rotationAngle;

        rotatingCubies.forEach(c => {
          c.position.applyAxisAngle(
            new THREE.Vector3(
              rotationAxis === 'x' ? 1 : 0,
              rotationAxis === 'y' ? 1 : 0,
              rotationAxis === 'z' ? 1 : 0
            ), rotationAngle);

          c.position.x = Math.round(c.position.x * 1000) / 1000;
          c.position.y = Math.round(c.position.y * 1000) / 1000;
          c.position.z = Math.round(c.position.z * 1000) / 1000;

          // Update userData coords
          c.userData.x = Math.round(c.position.x / (cubeUnitSize + cubeGap));
          c.userData.y = Math.round(c.position.y / (cubeUnitSize + cubeGap));
          c.userData.z = Math.round(c.position.z / (cubeUnitSize + cubeGap));

          rotatingGroup.remove(c);
          scene.add(c);
        });

        rotatingGroup.rotation.set(0, 0, 0);
        isRotating = false;
        rotationAxis = null;
        rotatingCubies = [];

        if (moveQueue.length) {
          const nextMove = moveQueue.shift();
          rotateLayer(nextMove.axis, nextMove.index, nextMove.clockwise);
        }
      } else {
        rotatingGroup.rotation[rotationAxis] += delta * (rotationAngle > 0 ? 1 : -1);
      }
    }

    // Scramble moves
    function scramble(times = 20) {
      if (isRotating) return;
      const moves = ['x', 'y', 'z'];
      moveQueue.length = 0;
      for(let i = 0; i < times; i++) {
        const axis = moves[Math.floor(Math.random() * 3)];
        const index = [-1, 0, 1][Math.floor(Math.random() * 3)];
        const clockwise = Math.random() > 0.5;
        moveQueue.push({ axis, index, clockwise });
      }
      if (!isRotating && moveQueue.length) {
        const nextMove = moveQueue.shift();
        rotateLayer(nextMove.axis, nextMove.index, nextMove.clockwise);
      }
    }

    // Solve: reset cube
    function solve() {
      if (isRotating) return;
      cubies.forEach(c => {
        scene.remove(c);
      });
      cubies.length = 0;
      for(let x = -1; x <= 1; x++) {
        for(let y = -1; y <= 1; y++) {
          for(let z = -1; z <= 1; z++) {
            const geometry = new THREE.BoxGeometry(cubeUnitSize, cubeUnitSize, cubeUnitSize);
            const materials = createCubieMaterials(x, y, z);
            const cubie = new THREE.Mesh(geometry, materials);
            cubie.position.set(
              x * (cubeUnitSize + cubeGap),
              y * (cubeUnitSize + cubeGap),
              z * (cubeUnitSize + cubeGap)
            );
            cubie.userData = { x, y, z };
            scene.add(cubie);
            cubies.push(cubie);
          }
        }
      }
    }

    // === Lock / Unlock Cube rotation ===
    const lockBtn = document.getElementById('lockBtn');
    let locked = false;

    lockBtn.addEventListener('click', () => {
      locked = !locked;
      controls.enabled = !locked;
      lockBtn.textContent = locked ? 'Unlock Cube (Enable Full Rotation)' : 'Lock Cube (Enable Slice Rotation)';
    });

    // Raycaster and mouse/touch for slice rotation
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let dragging = false;
    let dragStartPoint = null;
    let dragStartPos = null;
    let selectedCubie = null;
    let selectedFaceNormal = null;
    let dragPlane = new THREE.Plane();
    let dragIntersect = new THREE.Vector3();

    // Calculate mouse/touch coords normalized
    function getMousePos(event) {
      const rect = container.getBoundingClientRect();
      let x, y;
      if (event.touches) {
        x = event.touches[0].clientX;
        y = event.touches[0].clientY;
      } else {
        x = event.clientX;
        y = event.clientY;
      }
      mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
      mouse.y = - ((y - rect.top) / rect.height) * 2 + 1;
    }

    // Find intersected cubie and face normal
    function getIntersect(event) {
      getMousePos(event);
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubies);
      if (intersects.length) {
        return intersects[0];
      }
      return null;
    }

    // Mouse / touch down
    function onPointerDown(event) {
      if (!locked || isRotating) return;
      const intersect = getIntersect(event);
      if (!intersect) return;

      dragging = true;
      selectedCubie = intersect.object;
      selectedFaceNormal = intersect.face.normal.clone();
      dragStartPoint = intersect.point.clone();
      dragStartPos = { x: event.clientX || event.touches[0].clientX, y: event.clientY || event.touches[0].clientY };

      // Set drag plane perpendicular to camera view and intersect point
      dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()).clone().negate(), intersect.point);
    }

    // Mouse / touch move
    function onPointerMove(event) {
      if (!dragging || !locked || isRotating) return;

      // Calculate drag vector on dragPlane
      getMousePos(event);
      raycaster.setFromCamera(mouse, camera);
      if (raycaster.ray.intersectPlane(dragPlane, dragIntersect)) {
        const dragVector = new THREE.Vector3().subVectors(dragIntersect, dragStartPoint);
        if (dragVector.length() > 0.3) { // threshold to start rotation
          // Determine rotation axis and layer based on dragVector and face normal

          // We choose the primary axis closest to the drag
          const absX = Math.abs(dragVector.x);
          const absY = Math.abs(dragVector.y);
          const absZ = Math.abs(dragVector.z);

          // Determine axis for rotation
          let axis, index, clockwise;

          // Cross product of face normal and drag direction to find rotation axis
          const dragDir = dragVector.clone().normalize();
          const axisVec = new THREE.Vector3().crossVectors(selectedFaceNormal, dragDir).round();

          // Find axis letter from axisVec
          if (Math.abs(axisVec.x) > 0.5) axis = 'x';
          else if (Math.abs(axisVec.y) > 0.5) axis = 'y';
          else axis = 'z';

          // Find index for layer from selected cubie's userData
          index = selectedCubie.userData[axis];

          // Determine clockwise or counterclockwise by dot product of dragDir and axisVec cross
          const sign = dragDir.dot(axisVec);
          clockwise = sign > 0;

          // Enqueue rotation move and reset dragging
          moveQueue.push({ axis, index, clockwise });
          dragging = false;
        }
      }
    }

    // Mouse / touch up
    function onPointerUp(event) {
      dragging = false;
      selectedCubie = null;
      selectedFaceNormal = null;
    }

    container.addEventListener('mousedown', onPointerDown);
    container.addEventListener('touchstart', onPointerDown, { passive: false });

    container.addEventListener('mousemove', onPointerMove);
    container.addEventListener('touchmove', onPointerMove, { passive: false });

    container.addEventListener('mouseup', onPointerUp);
    container.addEventListener('touchend', onPointerUp);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      animateRotation();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });

    // Buttons
    document.getElementById('scrambleBtn').addEventListener('click', () => {
      if (!locked) {
        alert('Please lock the cube first to scramble.');
        return;
      }
      scramble(25);
    });

    document.getElementById('solveBtn').addEventListener('click', () => {
      if (isRotating) return;
      solve();
    });
  })();
  </script>
</body>
</html>
